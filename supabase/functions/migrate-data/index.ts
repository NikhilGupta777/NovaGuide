import { createClient } from "https://esm.sh/@supabase/supabase-js@2.49.1";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

// Old project credentials (service role key stored as secret to bypass RLS)
const OLD_URL = "https://skgbtoeipxijopliyjbx.supabase.co";
const OLD_SERVICE_ROLE_KEY = Deno.env.get("OLD_SUPABASE_SERVICE_ROLE_KEY")!;

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const oldClient = createClient(OLD_URL, OLD_SERVICE_ROLE_KEY);

    // New project uses service role to bypass RLS for inserts
    const newClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
    );

    const log: string[] = [];
    const addLog = (msg: string) => {
      console.log(msg);
      log.push(msg);
    };

    // ‚îÄ‚îÄ 1. Migrate categories ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üìÇ Fetching categories from old DB...");
    const { data: oldCategories, error: catErr } = await oldClient
      .from("categories")
      .select("*")
      .order("sort_order", { ascending: true });

    if (catErr) {
      addLog(`‚ùå Error fetching categories: ${catErr.message}`);
    } else if (oldCategories && oldCategories.length > 0) {
      addLog(`Found ${oldCategories.length} categories`);

      // Delete existing categories first so we can use the old IDs
      await newClient.from("categories").delete().neq("id", "00000000-0000-0000-0000-000000000000");
      addLog("Cleared seed categories");

      // Strip columns that don't exist in the new schema
      const cleanedCats = oldCategories.map((c: any) => {
        const { parent_id, ...rest } = c;
        return rest;
      });

      const { error: catInsertErr } = await newClient
        .from("categories")
        .upsert(cleanedCats, { onConflict: "slug" });

      if (catInsertErr) {
        addLog(`‚ùå Error inserting categories: ${catInsertErr.message}`);
      } else {
        addLog(`‚úÖ Migrated ${oldCategories.length} categories`);
      }
    } else {
      addLog("No categories found in old DB");
    }

    // ‚îÄ‚îÄ 2. Migrate articles (paginated - handle >1000) ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üì∞ Fetching articles from old DB...");
    let allArticles: any[] = [];
    let page = 0;
    const pageSize = 500;

    while (true) {
      const from = page * pageSize;
      const to = from + pageSize - 1;
      const { data: batch, error: artErr } = await oldClient
        .from("articles")
        .select("*")
        .order("created_at", { ascending: true })
        .range(from, to);

      if (artErr) {
        addLog(`‚ùå Error fetching articles page ${page}: ${artErr.message}`);
        break;
      }
      if (!batch || batch.length === 0) break;
      allArticles = allArticles.concat(batch);
      addLog(`  Fetched page ${page + 1}: ${batch.length} articles`);
      if (batch.length < pageSize) break;
      page++;
    }

    if (allArticles.length > 0) {
      addLog(`Found ${allArticles.length} total articles, inserting...`);

      // Insert in batches of 100
      for (let i = 0; i < allArticles.length; i += 100) {
        const chunk = allArticles.slice(i, i + 100);
        // Remove search_vector as it's auto-generated by trigger
        const cleaned = chunk.map((a: any) => {
          const { search_vector, ...rest } = a;
          return rest;
        });

        const { error: artInsertErr } = await newClient
          .from("articles")
          .upsert(cleaned, { onConflict: "slug" });

        if (artInsertErr) {
          addLog(`‚ùå Error inserting articles batch ${i / 100 + 1}: ${artInsertErr.message}`);
        } else {
          addLog(`  ‚úÖ Inserted batch ${i / 100 + 1} (${chunk.length} articles)`);
        }
      }
      addLog(`‚úÖ Migrated ${allArticles.length} articles total`);
    } else {
      addLog("No articles found in old DB");
    }

    // ‚îÄ‚îÄ 3. Migrate article_feedback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üëç Fetching article feedback...");
    const { data: oldFeedback, error: fbErr } = await oldClient
      .from("article_feedback")
      .select("*");

    if (fbErr) {
      addLog(`‚ö†Ô∏è article_feedback: ${fbErr.message}`);
    } else if (oldFeedback && oldFeedback.length > 0) {
      const { error: fbInsertErr } = await newClient
        .from("article_feedback")
        .upsert(oldFeedback, { onConflict: "id" });
      if (fbInsertErr) {
        addLog(`‚ùå Error inserting feedback: ${fbInsertErr.message}`);
      } else {
        addLog(`‚úÖ Migrated ${oldFeedback.length} feedback entries`);
      }
    } else {
      addLog("No feedback found");
    }

    // ‚îÄ‚îÄ 4. Migrate contact_submissions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üì¨ Fetching contact submissions...");
    const { data: oldContacts, error: contactErr } = await oldClient
      .from("contact_submissions")
      .select("*");

    if (contactErr) {
      addLog(`‚ö†Ô∏è contact_submissions: ${contactErr.message}`);
    } else if (oldContacts && oldContacts.length > 0) {
      const { error: cInsertErr } = await newClient
        .from("contact_submissions")
        .upsert(oldContacts, { onConflict: "id" });
      if (cInsertErr) {
        addLog(`‚ùå Error inserting contacts: ${cInsertErr.message}`);
      } else {
        addLog(`‚úÖ Migrated ${oldContacts.length} contact submissions`);
      }
    } else {
      addLog("No contact submissions found");
    }

    // ‚îÄ‚îÄ 5. Migrate email_subscribers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üìß Fetching email subscribers...");
    const { data: oldSubs, error: subErr } = await oldClient
      .from("email_subscribers")
      .select("*");

    if (subErr) {
      addLog(`‚ö†Ô∏è email_subscribers: ${subErr.message}`);
    } else if (oldSubs && oldSubs.length > 0) {
      const { error: sInsertErr } = await newClient
        .from("email_subscribers")
        .upsert(oldSubs, { onConflict: "email" });
      if (sInsertErr) {
        addLog(`‚ùå Error inserting subscribers: ${sInsertErr.message}`);
      } else {
        addLog(`‚úÖ Migrated ${oldSubs.length} email subscribers`);
      }
    } else {
      addLog("No subscribers found");
    }

    // ‚îÄ‚îÄ 6. Migrate agent_runs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("ü§ñ Fetching agent runs...");
    const { data: oldRuns, error: runErr } = await oldClient
      .from("agent_runs")
      .select("*");

    if (runErr) {
      addLog(`‚ö†Ô∏è agent_runs: ${runErr.message}`);
    } else if (oldRuns && oldRuns.length > 0) {
      const { error: rInsertErr } = await newClient
        .from("agent_runs")
        .upsert(oldRuns, { onConflict: "id" });
      if (rInsertErr) {
        addLog(`‚ùå Error inserting agent runs: ${rInsertErr.message}`);
      } else {
        addLog(`‚úÖ Migrated ${oldRuns.length} agent runs`);
      }
    } else {
      addLog("No agent runs found");
    }

    // ‚îÄ‚îÄ 7. Migrate agent_logs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üìã Fetching agent logs...");
    const { data: oldLogs, error: logErr } = await oldClient
      .from("agent_logs")
      .select("*");

    if (logErr) {
      addLog(`‚ö†Ô∏è agent_logs: ${logErr.message}`);
    } else if (oldLogs && oldLogs.length > 0) {
      for (let i = 0; i < oldLogs.length; i += 100) {
        const chunk = oldLogs.slice(i, i + 100);
        const { error: lInsertErr } = await newClient
          .from("agent_logs")
          .upsert(chunk, { onConflict: "id" });
        if (lInsertErr) {
          addLog(`‚ùå Error inserting agent logs batch: ${lInsertErr.message}`);
        }
      }
      addLog(`‚úÖ Migrated ${oldLogs.length} agent logs`);
    } else {
      addLog("No agent logs found");
    }

    // ‚îÄ‚îÄ 8. Sync category article counts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    addLog("üîÑ Syncing category article counts...");
    const { data: cats } = await newClient.from("categories").select("id");
    if (cats) {
      for (const cat of cats) {
        const { count } = await newClient
          .from("articles")
          .select("*", { count: "exact", head: true })
          .eq("category_id", cat.id)
          .eq("status", "published");

        await newClient
          .from("categories")
          .update({ article_count: count || 0 })
          .eq("id", cat.id);
      }
      addLog("‚úÖ Category article counts synced");
    }

    addLog("üéâ Migration complete!");

    return new Response(JSON.stringify({ success: true, log }, null, 2), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (err) {
    console.error("Migration error:", err);
    return new Response(
      JSON.stringify({ success: false, error: String(err) }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
